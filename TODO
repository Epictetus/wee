* OgScaffolder: cache fields

* LiteralMethodCallback: use a simple symbol instead?

* brushes.rb: tags as constants

* Session.new(application)

* live updates

* transactions

* use it with databases 

* diverting html-renderer

* Add unit-tests for new global/local decorations

* MessageBox: Buttons: OK_Cancel, YES_NO, Confirm  

* req-handler gc interval

* use LiteralMethod object instead of block if callback(:method_name) is given

* log requests

* call method #backtrack from backtrack_state. you don't need to call super for #backtrack (at least for direct subclasses of Component).
* call method #setup from initialize. same reason as for #backtrack.  

* initialize the component inside the handler thread, not from within Session#initialize
 
* renamexxx_chain methods to: component_xxx, e.g. 
  - process_callbacks/process_callback_chain to process_callbacks/component_process_callbacks
  - ... to backtrack_state/component_backtrack_state
  - render/render_chain to render/component_render  

* callback -> core, how is the callback registry best done?

* Context.... reduce

* root_for -> script style etc.

* Application == Dispatcher... collection of Session classes (or RequestHandlers)

* file-comments != class-comments... remove them

application.template_manager = {
  My => {'html' => RDocTemplate.new('view/html/file.tmpl'), 'wap' => RDocTemplate.new('view/wap/file.tmpl')}
}

either this way, or reversed: flavour/style => template-manager

class My < TemplatedComponent
  def action_blah
  end
  def action_blub
  end

  attr_accessor :blah

  # run-time 
  def template_flavour
    session.property['style'] || 'html'
  end
end

view/html/filt.tmpl:

  <form action="__action_blah">
    <input name="__input__blah">
  </form>

__action and __input get replaced

* unify RequestHandler/Session

* Wee = Web Engineering made Easy

callback.rb -> core
context -> core?

Wee::Callback: abstract
* values -> default_values
Wee::BlockCallback
* invoke -> call/[]

overthink CallbackStream
CallbackStream abstracts from the Request.
use only blocks as callbacks.

* different models:

  M = Model, V = View, C = Controller

  M: e.g. use ActiveRecord as model
  V: use external templates 
  C: Wee::Component

  MC: Wee::Component
  V: external template

  MVC: Wee::Component

* callbacks.create_callback_stream -> create_stream

* better webrick

* AbstractSession: 
  
  last_access: time of last access

  expires_after: expires after n seconds of inactivity (Time.now - last_access > expires_after) if expires_after.not_nil?
  expires_after = n_seconds

  max_lifetime: how long may this session run in total?  nil == infinity
  max_lifetime = 

  Session#terminate: quits a session 

    Application.remove_session(self.session_id)

  Session#session_id
  Session#application

Application also stores other RequestHandlers. Session is one RequestHandler.

  class RequestHandler
    attr_reader :application

    attr_reader :last_access
    attr_accessor :expires_after, :max_lifetime

    def alive?
      returns true if it should not be terminated
    end
  end

* Decoration#owner: use a ValueHolder, too. and register it for being backtracked.

* mark_objects_for_backtracking() instead of state-registry (snapshot_objects)

* improve error messages
